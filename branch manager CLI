ğŸŒ¿ Git Branch Manager CLI
Title & Objective
Title: Git Branch Manager CLI - A Beginner's Toolkit for Go Development

Objective: This project provides an interactive command-line interface for managing Git branches efficiently. Built with Go, it demonstrates fundamental CLI development concepts while providing a practical tool for daily Git workflow management.

The goal is to provide:

An intuitive interface for common Git branch operations
A learning reference for Go CLI development
Safe branch management with confirmation prompts
Colorful, user-friendly terminal output
Quick Summary of the Technology
What is Go?
Go (Golang) is a statically typed, compiled programming language designed by Google. It's known for its simplicity, fast compilation, built-in concurrency support, and excellent performance. Go is particularly well-suited for CLI tools, web services, and system programming.

Why Go for CLI Applications?
Single Binary: Go compiles to a single executable with no dependencies
Cross-Platform: Easy to build for Windows, macOS, and Linux
Fast Execution: Compiled binaries run extremely fast
Simple Standard Library: Built-in packages for I/O, OS operations, and command execution
Easy Distribution: Just copy the binaryâ€”no runtime needed
Real-World Examples:
Docker: Container platform built with Go
Kubernetes: Container orchestration system
Hugo: Static site generator
Terraform: Infrastructure as code tool
System Requirements
Operating System
Windows, macOS, or Linux
Tools Required
Go 1.16 or higher (installed via official installer)
Git (for the CLI to manage branches)
A terminal/command prompt
Recommended Editor
VS Code with the Go extension
GoLand (JetBrains)
Any text editor with Go support
Installation & Setup Instructions
Step 1: Install Go
Windows
Visit https://go.dev/dl/
Download the Windows installer (.msi file)
Run the installer and follow the prompts
The installer automatically sets up your PATH
macOS
bash
# Using Homebrew
brew install go

# Or download from https://go.dev/dl/
# Then run the .pkg installer
Linux
bash
# Ubuntu/Debian
sudo apt update
sudo apt install golang-go

# Or download from https://go.dev/dl/ and extract:
wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin
Step 2: Verify Installation
bash
go version
# Should output: go version go1.21.0 ...
Step 3: Set Up Go Workspace (Optional but Recommended)
bash
# Create a workspace directory
mkdir -p ~/go-projects
cd ~/go-projects
Step 4: Create the Project
bash
# Create project directory
mkdir branch-manager-cli
cd branch-manager-cli

# Initialize Go module
go mod init github.com/yourusername/branch-manager-cli

# Create main.go file
# Copy the code from the artifact into main.go
Step 5: Build and Run
bash
# Run directly without building
go run main.go

# Build an executable
go build -o branch-manager

# Run the built executable
./branch-manager          # macOS/Linux
.\branch-manager.exe      # Windows
Features
1. ğŸ“‹ List All Branches
View all local and remote branches in your repository with color-coded output showing the current branch.

2. â• Create a New Branch
Create a new branch with an optional immediate switch to the newly created branch.

3. ğŸ”„ Switch Branches
Easily switch between existing branches with a simple interactive prompt.

4. ğŸ—‘ï¸ Delete a Branch
Safely delete branches with confirmation prompts. Offers force delete option for branches with unmerged changes.

5. âœï¸ Rename a Branch
Rename the current branch or any other branch in your repository.

6. ğŸ“ Show Current Branch
Display the currently checked-out branch along with the last commit information.

7. ğŸ”€ Merge Branches
Merge any branch into your current branch with clear feedback on the operation.

8. ğŸ” Compare Branches
See the differences between two branches, showing commits unique to each branch.

9. ğŸšª Exit
Gracefully exit the application.






main branch code


package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// ANSI color codes for better UX
const (
	colorReset  = "\033[0m"
	colorRed    = "\033[31m"
	colorGreen  = "\033[32m"
	colorYellow = "\033[33m"
	colorBlue   = "\033[34m"
	colorPurple = "\033[35m"
	colorCyan   = "\033[36m"
)

type BranchManager struct {
	scanner *bufio.Scanner
}

func NewBranchManager() *BranchManager {
	return &BranchManager{
		scanner: bufio.NewScanner(os.Stdin),
	}
}

func main() {
	bm := NewBranchManager()
	bm.Run()
}

func (bm *BranchManager) Run() {
	bm.printWelcome()

	for {
		bm.printMenu()
		choice := bm.getInput("Enter your choice: ")

		switch choice {
		case "1":
			bm.listBranches()
		case "2":
			bm.createBranch()
		case "3":
			bm.switchBranch()
		case "4":
			bm.deleteBranch()
		case "5":
			bm.renameBranch()
		case "6":
			bm.currentBranch()
		case "7":
			bm.mergeBranch()
		case "8":
			bm.compareBranches()
		case "9":
			bm.addDataToBranch()
		case "10":
			fmt.Println(colorCyan + "\nğŸ‘‹ Thank you for using Branch Manager! Goodbye!" + colorReset)
			return
		default:
			fmt.Println(colorRed + "âŒ Invalid choice. Please try again." + colorReset)
		}

		fmt.Println() // Add spacing between operations
	}
}

func (bm *BranchManager) printWelcome() {
	fmt.Println(colorCyan + "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘   ğŸŒ¿ Git Branch Manager CLI ğŸŒ¿        â•‘")
	fmt.Println("â•‘   Manage your Git branches easily     â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" + colorReset)
	fmt.Println()
}

func (bm *BranchManager) printMenu() {
	fmt.Println(colorYellow + "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" + colorReset)
	fmt.Println(colorBlue + "Available Commands:" + colorReset)
	fmt.Println("  1. ğŸ“‹ List all branches")
	fmt.Println("  2. â• Create a new branch")
	fmt.Println("  3. ğŸ”„ Switch to a branch")
	fmt.Println("  4. ğŸ—‘ï¸  Delete a branch")
	fmt.Println("  5. âœï¸  Rename a branch")
	fmt.Println("  6. ğŸ“ Show current branch")
	fmt.Println("  7. ğŸ”€ Merge a branch")
	fmt.Println("  8. ğŸ” Compare branches")
	fmt.Println("  9. ğŸ“ Add data to current branch")
	fmt.Println("  10. ğŸšª Exit")
	fmt.Println(colorYellow + "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" + colorReset)
}

func (bm *BranchManager) getInput(prompt string) string {
	fmt.Print(colorPurple + prompt + colorReset)
	bm.scanner.Scan()
	return strings.TrimSpace(bm.scanner.Text())
}

func (bm *BranchManager) executeGitCommand(args ...string) (string, error) {
	cmd := exec.Command("git", args...)
	output, err := cmd.CombinedOutput()
	return string(output), err
}

func (bm *BranchManager) listBranches() {
	fmt.Println(colorCyan + "\nğŸ“‹ Listing all branches..." + colorReset)
	
	output, err := bm.executeGitCommand("branch", "-a", "--color=always")
	if err != nil {
		fmt.Println(colorRed + "âŒ Error: " + err.Error() + colorReset)
		return
	}

	fmt.Println(output)
}

func (bm *BranchManager) createBranch() {
	branchName := bm.getInput("\nâ• Enter new branch name: ")
	
	if branchName == "" {
		fmt.Println(colorRed + "âŒ Branch name cannot be empty!" + colorReset)
		return
	}

	// Create and immediately switch to the new branch
	output, err := bm.executeGitCommand("checkout", "-b", branchName)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to create branch: " + colorReset)
		fmt.Println(colorRed + output + colorReset)
		return
	}

	fmt.Println(colorGreen + "âœ… Branch '" + branchName + "' created and checked out successfully!" + colorReset)
}

func (bm *BranchManager) switchBranch() {
	fmt.Println(colorCyan + "\nğŸ”„ Available branches:" + colorReset)
	bm.listBranches()
	
	branchName := bm.getInput("\nEnter branch name to switch to: ")
	
	if branchName == "" {
		fmt.Println(colorRed + "âŒ Branch name cannot be empty!" + colorReset)
		return
	}

	_, err := bm.executeGitCommand("checkout", branchName)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to switch branch: " + err.Error() + colorReset)
		return
	}

	fmt.Println(colorGreen + "âœ… Switched to branch '" + branchName + "'" + colorReset)
}

func (bm *BranchManager) deleteBranch() {
	fmt.Println(colorCyan + "\nğŸ—‘ï¸  Available branches:" + colorReset)
	bm.listBranches()
	
	branchName := bm.getInput("\nEnter branch name to delete: ")
	
	if branchName == "" {
		fmt.Println(colorRed + "âŒ Branch name cannot be empty!" + colorReset)
		return
	}

	confirm := bm.getInput(colorYellow + "âš ï¸  Are you sure you want to delete '" + branchName + "'? (y/n): " + colorReset)
	if strings.ToLower(confirm) != "y" {
		fmt.Println(colorBlue + "â„¹ï¸  Deletion cancelled." + colorReset)
		return
	}

	_, err := bm.executeGitCommand("branch", "-d", branchName)
	if err != nil {
		fmt.Println(colorYellow + "âš ï¸  Cannot delete with -d. Try force delete? (y/n): " + colorReset)
		forceConfirm := bm.getInput("")
		if strings.ToLower(forceConfirm) == "y" {
			_, err := bm.executeGitCommand("branch", "-D", branchName)
			if err != nil {
				fmt.Println(colorRed + "âŒ Failed to delete branch: " + err.Error() + colorReset)
				return
			}
		} else {
			return
		}
	}

	fmt.Println(colorGreen + "âœ… Branch '" + branchName + "' deleted successfully!" + colorReset)
}

func (bm *BranchManager) renameBranch() {
	currentBranch, err := bm.executeGitCommand("branch", "--show-current")
	if err != nil {
		fmt.Println(colorRed + "âŒ Error getting current branch: " + err.Error() + colorReset)
		return
	}

	currentBranch = strings.TrimSpace(currentBranch)
	fmt.Println(colorCyan + "\nâœï¸  Current branch: " + currentBranch + colorReset)
	
	renameType := bm.getInput("Rename current branch or another? (current/other): ")
	
	var oldName, newName string
	
	if strings.ToLower(renameType) == "current" {
		oldName = currentBranch
		newName = bm.getInput("Enter new name for current branch: ")
	} else {
		bm.listBranches()
		oldName = bm.getInput("Enter branch name to rename: ")
		newName = bm.getInput("Enter new name: ")
	}

	if oldName == "" || newName == "" {
		fmt.Println(colorRed + "âŒ Branch names cannot be empty!" + colorReset)
		return
	}

	_, err = bm.executeGitCommand("branch", "-m", oldName, newName)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to rename branch: " + err.Error() + colorReset)
		return
	}

	fmt.Println(colorGreen + "âœ… Branch renamed from '" + oldName + "' to '" + newName + "'" + colorReset)
}

func (bm *BranchManager) currentBranch() {
	output, err := bm.executeGitCommand("branch", "--show-current")
	if err != nil {
		fmt.Println(colorRed + "âŒ Error: " + err.Error() + colorReset)
		return
	}

	branch := strings.TrimSpace(output)
	fmt.Println(colorGreen + "\nğŸ“ Current branch: " + branch + colorReset)
	
	// Show additional info
	info, _ := bm.executeGitCommand("log", "-1", "--oneline")
	if info != "" {
		fmt.Println(colorBlue + "Last commit: " + strings.TrimSpace(info) + colorReset)
	}
}

func (bm *BranchManager) mergeBranch() {
	currentBranch, err := bm.executeGitCommand("branch", "--show-current")
	if err != nil {
		fmt.Println(colorRed + "âŒ Error getting current branch: " + err.Error() + colorReset)
		return
	}

	currentBranch = strings.TrimSpace(currentBranch)
	fmt.Println(colorCyan + "\nğŸ”€ Current branch: " + currentBranch + colorReset)
	fmt.Println(colorCyan + "Available branches to merge:" + colorReset)
	bm.listBranches()
	
	branchToMerge := bm.getInput("\nEnter branch name to merge into current branch: ")
	
	if branchToMerge == "" {
		fmt.Println(colorRed + "âŒ Branch name cannot be empty!" + colorReset)
		return
	}

	if branchToMerge == currentBranch {
		fmt.Println(colorRed + "âŒ Cannot merge a branch into itself!" + colorReset)
		return
	}

	fmt.Println(colorYellow + "âš™ï¸  Merging '" + branchToMerge + "' into '" + currentBranch + "'..." + colorReset)
	
	output, err := bm.executeGitCommand("merge", branchToMerge)
	if err != nil {
		fmt.Println(colorRed + "âŒ Merge failed: " + err.Error() + colorReset)
		fmt.Println(output)
		return
	}

	fmt.Println(colorGreen + "âœ… Successfully merged '" + branchToMerge + "' into '" + currentBranch + "'" + colorReset)
	fmt.Println(output)
}

func (bm *BranchManager) compareBranches() {
	fmt.Println(colorCyan + "\nğŸ” Compare branches" + colorReset)
	bm.listBranches()
	
	branch1 := bm.getInput("\nEnter first branch name: ")
	branch2 := bm.getInput("Enter second branch name: ")
	
	if branch1 == "" || branch2 == "" {
		fmt.Println(colorRed + "âŒ Branch names cannot be empty!" + colorReset)
		return
	}

	fmt.Println(colorYellow + "\nğŸ“Š Commits in '" + branch1 + "' but not in '" + branch2 + "':" + colorReset)
	output1, err1 := bm.executeGitCommand("log", "--oneline", branch1, "^"+branch2)
	if err1 == nil && output1 != "" {
		fmt.Println(output1)
	} else {
		fmt.Println(colorBlue + "  (none)" + colorReset)
	}

	fmt.Println(colorYellow + "\nğŸ“Š Commits in '" + branch2 + "' but not in '" + branch1 + "':" + colorReset)
	output2, err2 := bm.executeGitCommand("log", "--oneline", branch2, "^"+branch1)
	if err2 == nil && output2 != "" {
		fmt.Println(output2)
	} else {
		fmt.Println(colorBlue + "  (none)" + colorReset)
	}
}

func (bm *BranchManager) addDataToBranch() {
	// Get current branch
	currentBranch, err := bm.executeGitCommand("branch", "--show-current")
	if err != nil {
		fmt.Println(colorRed + "âŒ Error getting current branch: " + err.Error() + colorReset)
		return
	}
	currentBranch = strings.TrimSpace(currentBranch)
	
	fmt.Println(colorCyan + "\nğŸ“ Add Data to Branch" + colorReset)
	fmt.Println(colorGreen + "Current branch: " + currentBranch + colorReset)

	// Get file operation choice
	fmt.Println(colorBlue + "\nWhat would you like to do?" + colorReset)
	fmt.Println("  1. Create a new file")
	fmt.Println("  2. Edit an existing file")
	fmt.Println("  3. Add multiple files")
	
	fileChoice := bm.getInput("Enter choice (1-3): ")

	switch fileChoice {
	case "1":
		bm.createNewFile()
	case "2":
		bm.editExistingFile()
	case "3":
		bm.addMultipleFiles()
	default:
		fmt.Println(colorYellow + "âš ï¸  Invalid choice." + colorReset)
		return
	}

	// Commit the changes
	bm.commitChanges(currentBranch)
}

func (bm *BranchManager) createBranchWithData() {
	fmt.Println(colorCyan + "\nğŸ“ Create Branch and Add Data" + colorReset)
	
	// Get branch name
	branchName := bm.getInput("Enter new branch name: ")
	if branchName == "" {
		fmt.Println(colorRed + "âŒ Branch name cannot be empty!" + colorReset)
		return
	}

	// Create and switch to branch
	output, err := bm.executeGitCommand("checkout", "-b", branchName)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to create branch: " + colorReset)
		fmt.Println(colorRed + output + colorReset)
		return
	}
	fmt.Println(colorGreen + "âœ… Branch '" + branchName + "' created!" + colorReset)

	// Get file operation choice
	fmt.Println(colorBlue + "\nWhat would you like to do?" + colorReset)
	fmt.Println("  1. Create a new file")
	fmt.Println("  2. Edit an existing file")
	fmt.Println("  3. Add multiple files")
	
	fileChoice := bm.getInput("Enter choice (1-3): ")

	switch fileChoice {
	case "1":
		bm.createNewFile()
	case "2":
		bm.editExistingFile()
	case "3":
		bm.addMultipleFiles()
	default:
		fmt.Println(colorYellow + "âš ï¸  Invalid choice. Skipping file operations." + colorReset)
		return
	}

	// Commit the changes
	bm.commitChanges(branchName)
}

func (bm *BranchManager) createNewFile() {
	filename := bm.getInput("\nğŸ“„ Enter filename (e.g., notes.txt): ")
	if filename == "" {
		fmt.Println(colorRed + "âŒ Filename cannot be empty!" + colorReset)
		return
	}

	fmt.Println(colorBlue + "Enter file content (type 'END' on a new line to finish):" + colorReset)
	
	var content strings.Builder
	for {
		line := bm.getInput("")
		if line == "END" {
			break
		}
		content.WriteString(line + "\n")
	}

	// Write file
	err := os.WriteFile(filename, []byte(content.String()), 0644)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to create file: " + err.Error() + colorReset)
		return
	}

	// Stage the file
	_, err = bm.executeGitCommand("add", filename)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to stage file: " + err.Error() + colorReset)
		return
	}

	fmt.Println(colorGreen + "âœ… File '" + filename + "' created and staged!" + colorReset)
}

func (bm *BranchManager) editExistingFile() {
	filename := bm.getInput("\nğŸ“ Enter filename to edit: ")
	if filename == "" {
		fmt.Println(colorRed + "âŒ Filename cannot be empty!" + colorReset)
		return
	}

	// Check if file exists
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		fmt.Println(colorRed + "âŒ File does not exist!" + colorReset)
		return
	}

	fmt.Println(colorBlue + "Enter content to APPEND to the file (type 'END' on a new line to finish):" + colorReset)
	
	var content strings.Builder
	for {
		line := bm.getInput("")
		if line == "END" {
			break
		}
		content.WriteString(line + "\n")
	}

	// Append to file
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to open file: " + err.Error() + colorReset)
		return
	}
	defer f.Close()

	_, err = f.WriteString(content.String())
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to write to file: " + err.Error() + colorReset)
		return
	}

	// Stage the file
	_, err = bm.executeGitCommand("add", filename)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to stage file: " + err.Error() + colorReset)
		return
	}

	fmt.Println(colorGreen + "âœ… File '" + filename + "' updated and staged!" + colorReset)
}

func (bm *BranchManager) addMultipleFiles() {
	fmt.Println(colorBlue + "\nğŸ“‚ Enter filenames to stage (one per line, type 'DONE' when finished):" + colorReset)
	
	var files []string
	for {
		filename := bm.getInput("")
		if filename == "DONE" {
			break
		}
		if filename != "" {
			files = append(files, filename)
		}
	}

	if len(files) == 0 {
		fmt.Println(colorYellow + "âš ï¸  No files specified." + colorReset)
		return
	}

	// Stage all files
	args := append([]string{"add"}, files...)
	output, err := bm.executeGitCommand(args...)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to stage files: " + colorReset)
		fmt.Println(colorRed + output + colorReset)
		return
	}

	fmt.Println(colorGreen + "âœ… Files staged successfully!" + colorReset)
}

func (bm *BranchManager) commitChanges(branchName string) {
	// Check if there are staged changes
	status, _ := bm.executeGitCommand("status", "--porcelain")
	if strings.TrimSpace(status) == "" {
		fmt.Println(colorYellow + "\nâš ï¸  No changes to commit." + colorReset)
		return
	}

	// Show what will be committed
	fmt.Println(colorCyan + "\nğŸ“‹ Changes to be committed:" + colorReset)
	stagedFiles, _ := bm.executeGitCommand("diff", "--cached", "--name-status")
	fmt.Println(stagedFiles)

	// Get commit message
	commitMsg := bm.getInput("\nğŸ’¬ Enter commit message: ")
	if commitMsg == "" {
		commitMsg = "Add data to branch " + branchName
	}

	// Commit
	output, err := bm.executeGitCommand("commit", "-m", commitMsg)
	if err != nil {
		fmt.Println(colorRed + "âŒ Failed to commit: " + colorReset)
		fmt.Println(colorRed + output + colorReset)
		return
	}

	fmt.Println(colorGreen + "\nâœ… Changes committed successfully!" + colorReset)
	fmt.Println(output)
	
	// Ask if user wants to push
	push := bm.getInput("\nğŸš€ Push to remote? (y/n): ")
	if strings.ToLower(push) == "y" {
		fmt.Println(colorYellow + "âš™ï¸  Pushing to remote..." + colorReset)
		pushOutput, pushErr := bm.executeGitCommand("push", "-u", "origin", branchName)
		if pushErr != nil {
			fmt.Println(colorRed + "âŒ Failed to push: " + colorReset)
			fmt.Println(colorRed + pushOutput + colorReset)
		} else {
			fmt.Println(colorGreen + "âœ… Pushed to remote successfully!" + colorReset)
		}
	}
}
